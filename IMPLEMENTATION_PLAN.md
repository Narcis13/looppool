# Implementation Plan

Generated by Ralph planning mode. Updated during building mode. Last updated: 2026-01-30 (Re-analyzed specifications and codebase)

**Verification Complete**: Confirmed via comprehensive codebase analysis:
- IDE implementation is at zero (src/ directory exists but is empty)
- All 5 IDE specifications exist and have been analyzed in detail
- Codebase contains exactly 426 markdown files
- Largest file is best-practices.md with 2,379 lines
- ralphy-main/ provides proven patterns for HTTP, file operations, and security

**Note**: The ralphy-main/ TypeScript CLI implementation provides valuable reference patterns for debouncing, path validation, and cross-platform support.

## Gap Analysis Summary

**Current State**: Zero IDE implementation. The src/ directory for IDE exists but is completely empty.

**Key Findings** (Verified 2026-01-30):
- All priorities 1-7 remain fully unimplemented for the IDE
- Package.json missing "ide" script for launching server
- No esbuild configuration exists for IDE despite devDependency installed
- Codebase contains exactly 426 markdown files across multiple directories
- Existing ralphy-main/ contains a complete TypeScript CLI framework (separate tool)
- Largest files confirmed: best-practices.md (2,379 lines), CHANGELOG.md (1,213 lines), lpl-debugger.md (1,203 lines)
- Security and performance requirements are critical given zero-deps philosophy
- YAML frontmatter format confirmed: name, description, argument-hint, allowed-tools
- Specs strongly emphasize avoiding dependencies (even popular ones like Express)
- File System Access API could be alternative to server-based approach (browser-only)
- Five complete IDE specifications exist in specs/ directory
- Note: .planning/ directory will be created by looppool-cc tool during project planning
- 50+ files exceed 500 lines, requiring robust virtual scrolling implementation

## Spec Alignment

**Core Requirements from Specifications**:
1. **ide-core.md**: Single-page app, left sidebar file tree, markdown editor with YAML support, under 1 second load time
2. **ide-server.md**: Lightweight Node.js server, localhost:3456, path validation, SSE for real-time updates
3. **ide-command-viewer.md**: Parse YAML frontmatter, show tool badges, copy/test buttons, relationship links
4. **ide-state-panel.md**: Display .planning/STATE.json, progress indicators, recent activity, quick actions
5. **ide-graph-view.md**: d3/cytoscape visualization, 50+ nodes support, color-coded node types, zoom/pan

## Priority 1: Core Server Infrastructure
- [x] Create src/server/index.js with native http module (why: zero deps, Express adds 50+ transitive dependencies)
- [x] Implement core security middleware: localhost binding, path validation with resolve+startsWith (why: prevent directory traversal attacks)
- [x] Add GET /api/tree endpoint returning JSON structure for commands/, looppool/, agents/, specs (why: IDE needs directory navigation)
- [x] Add GET /api/file?path=... endpoint with streaming for large files (why: largest file is 2,379 lines)
- [x] Add PUT /api/file?path=... endpoint with atomic writes using temp file + rename (why: prevent corruption on crash)
- [x] Set up SSE endpoint /api/events for real-time file change notifications (why: simpler than WebSocket, built into http)
- [x] Implement fs.watch with debouncing and path filtering (why: prevent notification storms across 426 files)
- [x] Add npm script "ide": "node src/server/index.js" to package.json (why: standard launch command)
- [x] Add browser auto-launch to localhost:3456 using platform-specific commands (why: better UX than manual URL)

## Priority 2: Frontend Foundation
- [ ] Create src/frontend/index.html with semantic HTML5 structure (why: accessibility and SEO)
- [ ] Implement CSS Grid layout: 250px sidebar, auto main, 40px top bar (why: standard IDE proportions)
- [ ] Build collapsible file tree with virtual scrolling for 100+ files (why: performance at scale)
- [ ] Add project name display and connection status indicator (why: user awareness)
- [ ] Implement EventSource client for SSE with reconnection logic (why: handle network interruptions)
- [ ] Add static file serving with proper MIME types in server (why: serve frontend assets)
- [ ] Create keyboard navigation for file tree (arrow keys, enter to open) (why: power user efficiency)
- [ ] Add file type icons using CSS classes (why: visual file identification)

## Priority 3: Markdown Editor
- [ ] Integrate CodeMirror 6 or similar lightweight editor (why: handles 1,200+ line files efficiently)
- [ ] Configure markdown syntax highlighting with YAML frontmatter support (why: core file format)
- [ ] Implement auto-save with 2-second debounce and dirty state tracking (why: prevent data loss)
- [ ] Add line numbers with efficient rendering for long files (why: debugging and navigation)
- [ ] Create save status indicator with pending/saving/saved states (why: user confidence)
- [ ] Add undo/redo with proper history management (why: essential editing feature)
- [ ] Implement find/replace with regex support (why: power user feature)
- [ ] Add vim key bindings option (why: developer preference)

## Priority 4: Command Viewer Enhancement
- [ ] Create custom YAML frontmatter parser for --- delimited blocks (why: avoid 17KB js-yaml library)
- [ ] Build metadata card UI component with consistent styling (why: visual hierarchy)
- [ ] Add tool badges with color coding and hover tooltips (why: quick capability reference)
- [ ] Implement "Copy as /lpl:command" button with clipboard API (why: terminal integration)
- [ ] Add "Test in terminal" button with proper shell escaping and argument handling (why: execute commands directly from IDE)
- [ ] Parse file references to create "View workflow" navigation (why: explore system hierarchy)
- [ ] Build relationship graph showing command→workflow→agent flow (why: understand architecture)
- [ ] Create tabbed view for metadata vs raw content (why: dual perspectives)
- [ ] Extract and display argument-hint field prominently (why: users need to know required arguments)

## Priority 5: State Panel Implementation
- [ ] Add GET /api/state endpoint reading .planning/STATE.json with caching (why: minimize file I/O)
- [ ] Implement file watching for entire .planning directory (why: track all planning document changes)
- [ ] Create state panel UI with 300px width and vertical sections (why: dashboard layout)
- [ ] Parse and display PROJECT.md with markdown rendering (why: project context)
- [ ] Extract phase/milestone data from ROADMAP.md using heading parsing (why: progress tracking)
- [ ] Calculate task completion from PLAN.md checkbox parsing (why: quantify progress)
- [ ] Build circular progress indicators using SVG (why: compact visualization)
- [ ] Create activity feed from git log parsing (last 10 commits) (why: recent changes awareness)
- [ ] Add collapsible planning document tree showing all .planning files (why: quick document access)
- [ ] Implement "Resume work" button opening CONTINUE_HERE.md (why: restore context quickly)
- [ ] Add "View decisions" linking to DECISIONS.md with anchor navigation (why: review reasoning)

## Priority 6: Graph Visualization
- [ ] Create graph data parser extracting relationships from file content (why: build node/edge data)
- [ ] Implement d3-force or cytoscape.js with hierarchical positioning constraints (why: enforce layer structure)
- [ ] Configure force simulation: charge -300, link distance by type (why: readable layout)
- [ ] Style nodes: Commands=blue, Workflows=green, Agents=orange, Templates=gray (why: visual grammar)
- [ ] Add zoom and pan behavior with min=0.1, max=4 constraints (why: explore dense graphs)
- [ ] Implement node highlighting on hover with connected edge emphasis (why: trace relationships)
- [ ] Add double-click handler to open files in editor (why: integrated navigation)
- [ ] Create type filter checkboxes for node visibility (why: focus on subsystems)
- [ ] Ensure performant rendering for 50+ nodes baseline (why: spec requirement)
- [ ] Optimize for 100+ nodes using canvas fallback if needed (why: future-proofing for scale)
- [ ] Add layout persistence in localStorage (why: maintain user arrangements)

## Priority 7: Polish and Performance
- [ ] Implement request debouncing for file tree operations (why: reduce server load)
- [ ] Add file content caching with ETag validation (why: minimize redundant transfers)
- [ ] Create comprehensive keyboard shortcuts (Cmd/Ctrl+S, Cmd/Ctrl+P for quick open) (why: IDE expectations)
- [ ] Build error boundary components with user-friendly messages (why: graceful degradation)
- [ ] Add --port and --root CLI arguments with validation (why: deployment flexibility)
- [ ] Implement rate limiting for API endpoints (why: prevent accidental DoS)
- [ ] Create loading skeletons for async operations (why: perceived performance)
- [ ] Add telemetry-free analytics using local storage (why: improve without privacy concerns)
- [ ] Build settings panel for editor preferences (why: user customization)
- [ ] Package as single executable using Node.js single executable applications (why: distribution simplicity)

## Priority 8: Accessibility and Error Handling
- [ ] Add ARIA labels and roles for all interactive elements (why: screen reader support)
- [ ] Implement high contrast mode toggle (why: visual accessibility)
- [ ] Ensure complete keyboard navigation with visible focus indicators (why: keyboard-only users)
- [ ] Create error recovery for corrupted YAML frontmatter (why: graceful handling of malformed files)
- [ ] Add fallback rendering for invalid markdown files (why: prevent editor crashes)
- [ ] Implement network interruption recovery with queued operations (why: data loss prevention)
- [ ] Add file locking mechanism for concurrent edit detection (why: prevent conflicting changes)
- [ ] Create conflict resolution UI for simultaneous edits (why: multi-window safety)

## Priority 9: Testing Infrastructure
- [ ] Set up Playwright for cross-browser E2E testing (why: automated regression prevention)
- [ ] Create performance benchmarking suite with baseline thresholds (why: prevent performance regressions)
- [ ] Implement visual regression testing for UI components (why: catch unintended style changes)
- [ ] Add integration tests for all API endpoints (why: backend stability)
- [ ] Create mock file system for unit testing file operations (why: test isolation)
- [ ] Set up continuous testing in CI/CD pipeline (why: catch issues early)

## Implementation Notes

### Patterns from ralphy-main CLI to Reuse
- **HTTP/Webhook patterns**: Native fetch with AbortController for timeouts (verified in `ralphy-main/cli/src/telemetry/webhook.ts`)
- **File system security**: Path validation patterns for safe file access
- **File caching**: Memory caching with debounced writes (see `ralphy-main/cli/src/tasks/cached-task-source.ts`)
- **Sandbox isolation**: Isolated execution directories with symlinks (see `ralphy-main/cli/src/sandbox.ts`)
- **Cross-platform support**: Platform detection using process.platform (verified in `ralphy-main/cli/src/engines/base.ts`)
- **Error handling**: Graceful degradation with defaults instead of throwing
- **Debouncing**: Essential patterns for auto-save and flush operations with retry logic (verified in cached-task-source.ts)
- **Resource cleanup**: Proper cleanup management for watchers, timers, and connections

### Specific Code Patterns to Adopt

#### YAML Frontmatter Format (Confirmed)
```yaml
---
name: lpl:command-name
description: One-line description of what the command does
argument-hint: "<required>" or "[optional]" or ""
allowed-tools:
  - Read
  - Write
  - Bash
  - Glob
  - Grep
  - AskUserQuestion
---
```

#### Path Validation (Critical for Security)
```javascript
const resolvedPath = path.resolve(rootDir, requestedPath);
if (!resolvedPath.startsWith(rootDir)) {
    throw new Error('Path traversal attempt detected');
}
```

#### Native Fetch with Error Handling
```javascript
const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
});
if (!response.ok) {
    const text = await response.text().catch(() => '');
    throw new Error(`Request failed: ${response.status}${text ? ` - ${text}` : ''}`);
}
```

#### Debounced File Operations
```javascript
let flushTimer = null;
function scheduleFlush() {
    if (flushTimer) return;
    flushTimer = setTimeout(() => {
        flushTimer = null;
        flush().catch(err => {
            console.error('Flush failed:', err);
            scheduleFlush(); // Retry
        });
    }, FLUSH_INTERVAL_MS);
}
```

#### Cross-Platform Command Detection
```javascript
const isWindows = process.platform === 'win32';
const checkCommand = isWindows ? 'where' : 'which';
const openCommand = isWindows ? 'start' : (process.platform === 'darwin' ? 'open' : 'xdg-open');
```

### Zero-Dependency Philosophy
- **Core principle**: Every dependency adds maintenance burden and security risk
- **Prefer native APIs**: Use built-in Node.js and browser features wherever possible
- **Custom implementations**: Write simple parsers instead of importing libraries (e.g., YAML frontmatter)
- **Justified exceptions**: Only add dependencies when custom implementation would be prohibitively complex (e.g., CodeMirror for editor)
- **Bundle size awareness**: Every KB matters for load time
- **Atomic operations**: Use temp files + rename for safe writes

### Performance Targets
- Initial page load: < 500ms (HTML + critical CSS)
- File tree render: < 100ms for 100 files
- File open: < 50ms for average file (350 lines)
- File save: < 100ms including filesystem write
- Graph render: < 200ms for 100 nodes

### Security Checklist
- [ ] All paths validated with resolve() + startsWith()
- [ ] Server binds to 127.0.0.1, not 0.0.0.0
- [ ] No eval() or Function() constructor usage
- [ ] Content Security Policy headers set
- [ ] All user input escaped in HTML rendering
- [ ] File write permissions checked before operations
- [ ] Input validation on all API endpoints
- [ ] Rate limiting to prevent DoS

### Browser Support Matrix
- Chrome 100+ (87% developer market share)
- Firefox 100+ (8% developer market share)  
- Safari 15+ (4% developer market share)
- No IE/Legacy Edge support required

### Additional Patterns from ralphy-main Analysis

#### Enhanced Auto-Save with Retry Logic
```javascript
// Pattern: Retry failed saves with exponential backoff
class AutoSaveManager {
    private pendingSaves = new Map<string, string>();
    private retryCount = new Map<string, number>();
    private readonly MAX_RETRIES = 3;
    
    async scheduleSave(filePath: string, content: string) {
        this.pendingSaves.set(filePath, content);
        this.scheduleFlush();
    }
    
    hasPendingWrites(): boolean {
        return this.pendingSaves.size > 0;
    }
}
```

#### File Modification Tracking
```javascript
// Pattern: Detect external changes efficiently
class FileChangeDetector {
    private fileStats = new Map<string, {mtime: number, size: number}>();
    
    async hasChanged(filePath: string): Promise<boolean> {
        const cached = this.fileStats.get(filePath);
        const stat = await fs.stat(filePath);
        return stat.mtimeMs !== cached.mtime || stat.size !== cached.size;
    }
}
```

#### JSONL Event Logging
```javascript
// Pattern: Efficient append-only logging for IDE events
class IDEEventLog {
    async logEvent(event: {type: string, timestamp: number, data: any}) {
        const line = JSON.stringify(event) + '\n';
        await fs.appendFile('.looppool/.ide-events.jsonl', line);
    }
}
```

#### Operation Progress Tracking
```javascript
// Pattern: Track long-running operation steps with timing
class OperationTracker {
    recordStep(operationId: string, stepName: string) {
        // Track "Parsing YAML", "Building graph", "Rendering nodes" etc.
    }
}
```

#### Rate Limiting with Sliding Window
```javascript
// Pattern: Prevent API abuse with efficient sliding window
class RateLimiter {
    private requests = new Map<string, number[]>();
    isAllowed(clientId: string): boolean {
        // Track requests per minute with automatic cleanup
    }
}
```

#### Virtual Scrolling Buffer Management
```javascript
// Pattern: Smooth scrolling for large files with buffer zones
getVisibleLines(scrollTop: number): {start: number, end: number} {
    const bufferSize = 10; // Pre-render lines above/below viewport
    // Calculate visible range with buffer for smooth scrolling
}
```

#### Resource Cleanup Manager
```javascript
// Pattern: Graceful shutdown with ordered cleanup
class ResourceManager {
    register(cleanup: () => Promise<void>) {
        // Register watchers, connections, temp files for cleanup
    }
    async cleanup() {
        // Execute all cleanup tasks in parallel with error isolation
    }
}
```

### Technical Decisions
1. **Native modules over frameworks**: http vs Express, fs vs fs-extra
2. **Vanilla JS initially**: Add build step only when modularization needed
3. **SSE over WebSocket**: Simpler, unidirectional updates sufficient
4. **Virtual scrolling**: Required for 1,200+ line files
5. **LocalStorage over cookies**: Better API, no size limits
6. **Canvas fallback for graph**: SVG performance degrades at 200+ nodes
7. **Server-based over File System Access API**: Better browser compatibility, though FSA API remains an option for Chrome/Edge-only deployment
8. **Atomic writes**: Always use temp file + rename pattern
9. **Platform detection**: Explicit handling rather than assuming POSIX
10. **Retry mechanisms**: Essential for network operations and file saves
11. **Event logging**: JSONL format for efficient append-only operations
12. **Progress tracking**: User feedback for operations over 100ms

## Testing Strategy

### Unit Testing Priorities
1. Path validation functions (security critical)
2. YAML frontmatter parser (data integrity)
3. Graph relationship parser (correctness)
4. File change debouncer (reliability)
5. Atomic write operations (data safety)

### Integration Testing Flow
1. Start server → Verify port binding
2. Open browser → Check auto-launch
3. Navigate files → Test tree operations
4. Edit file → Verify save and SSE update
5. Check security → Attempt path traversal
6. Test performance → Open largest file
7. Verify cross-platform → Test on Windows, macOS, Linux

### Manual QA Checklist
- [ ] Verify all 426 files appear in tree
- [ ] Open lpl-debugger.md (1,203 lines) or best-practices.md (2,379 lines)
- [ ] Edit and verify auto-save works
- [ ] Test graph with all nodes visible
- [ ] Check state panel shows real data
- [ ] Verify command viewer parses frontmatter
- [ ] Test keyboard navigation throughout
- [ ] Verify works on all target browsers
- [ ] Test atomic writes don't corrupt on crash
- [ ] Verify path traversal attacks are blocked

## Recommended Implementation Order

**Phase 1 - Foundation (Critical Path)**:
1. Priority 1, tasks 1-5: Core server with file APIs and security
2. Priority 2, tasks 1-3: Minimal frontend with file tree
3. Priority 3, tasks 1-4: Basic markdown editor with save

**Phase 2 - Core Features**:
4. Priority 4, tasks 1-4: Command viewer with YAML parsing
5. Priority 5, tasks 1-4: State panel basics
6. Test end-to-end integration

**Phase 3 - Advanced Features**:
7. Priority 6: Complete graph visualization
8. Remaining Priority 4-5 tasks
9. Priority 7: Polish and performance optimizations

**Phase 4 - Quality Assurance**:
10. Priority 8: Accessibility and error handling
11. Priority 9: Testing infrastructure

**Critical Success Factors**:
- Maintain zero-dependency philosophy throughout
- Test with 1,200+ line files from day one
- Ensure sub-second load time from the start
- Security validation on every file operation
- Use proven patterns from ralphy-main
- Implement accessibility from the start (progressive enhancement)

## Potential Risks and Mitigations
- **Risk**: Editor performance with large files
  - **Mitigation**: Virtual scrolling, lazy syntax highlighting, streaming file reads
- **Risk**: Graph layout with 100+ nodes
  - **Mitigation**: Canvas renderer, node clustering option
- **Risk**: File corruption during saves
  - **Mitigation**: Atomic writes, backup on edit start, write verification
- **Risk**: Browser compatibility issues
  - **Mitigation**: Progressive enhancement, feature detection
- **Risk**: SSE connection drops
  - **Mitigation**: Automatic reconnection with exponential backoff
- **Risk**: Memory leaks from file watchers
  - **Mitigation**: Proper cleanup, watcher limits, debouncing